
当Flink程序重新启动的时候,
那么这些每个单词它的数量难道要重新计算吗?
因为我们的数据是流动的,它不是禁止不变的,
历史的数据已经流走了。
这个重新计算又是从何开始重新计算呢?
为了解决这个问题,Flink就提出了状态机制。
前一节课已经讲解了Flink状态机制它的理论之时,
这节课就通过代码来演示Flink基于状态计算实现WaterCount。
首先建立一个包叫做Stable,
表示这个包是用来存放状态计算的文件的,
然后在这个Stable的包下面建立一个WaterCount的包,
我们这节课所建立的文件都是放在Stable包下面的WaterCount这个包里面。
然后建立一个组类,
这个组类就是基于状态计算实现食品统计,
然后建立Made方法。
Flink基于流逝计算它的基本步骤是不变的,
第一步就是加载上下文款进,
第二步就是加载数据。
同样的加载数据这里是使用Socket Pass Stream这个方法来监听888这个端口,
反回的是Data Stream的数据类型。
第三步就是数据的转换和处理。
在这一步里面主要是workout的逻辑的编写,
workout的四个步骤也是不变的对单词的签歌,
然后对签歌完成后的单词进行标记,
对标记完成后的单词进行分组,
然后对同意组的单词将他们的标记进行聚合。
最后就是数据的输出,
数据的输出同样的Data Stream API是要执行sql的这些方法
才会触发程序的执行的。
这些内容都是在前几节课已经讲过了,
这里就不详细的去缠述,
然后对数据流应用Fatmap这个算子,
因为我们这里是应用Lambda的表达是,
我们就不需要New一个Fatmap Function的对象,
直接调用Fatmap Function对象它的Fatmap方法。
这些也是在前面的课程讲过了,
这里就不详细的去缠述,
然后Fatmap这个方法里面我们还记得吗?
有两个参数,
一个是输入参数,
第二个是输出参数,
然后主要的我们是看它输出参数,
输出参数它是一个Connect对象,
在前面的课程里面Connect对象它的Fat型是Stream内型,
也就是我们输出的是一个一个的单词,
现在我们换一种显法,
我们建立一个What the Count的一个实体类来代替这个Stream内型,
也就是说Fatmap这个算子它的输出是What the Count的实体类,
所以我们建立一个What the Count的实体类,
这个实体类它的属性有哪些呢?
根据明朝我们已经很清楚的知道,
这个实体类需要两个属性,
一个是单词,单词是Stream内型,
第二个属性是单词的数量,
每个单词它的数量,
这里数量是Integer内型,
这个What the Count的实体类主要就是有这两个属性,
然后我们建立这两个属性它的Getter and Sector的方法,
接下来就是建立两个它的构造方法,
第一个有两个构造方法,
一个是无参的构造方法,
我们先建立一个无参的构造方法,
这是无参的构造方法,
接下来是有参的构造方法,
这里的有参的构造方法,
它的参数有两个,
就是主要是这两个属性单词,
以及每个单词它的数量,
这是有参的构造方法,
然后解一下,
这个是单词,
这个是单词的数量,
是每个单词,
那么我看这个实体类就已经完成了,
接下来我们进行第一步的切割,
对数据流的数据进行切割,
按照空格将数据进行切割,
把每个单词,每条数据,
它的每个单词按照空格,
把它一个一个单词切割出来,
然后放到一个制服串数据里面,
接下来我们循环这个制服串数据,
通过加强FOR这个语法,
把数据里面的每个单词把它取出,
然后通过这个Connect对象,
也就是Output这个变量,
它的一个方法,Connect这个方法,
把数据将它返回去,
那么现在我们这里的Connect,
我们指定了它的里面的犯行是work on这个对象,
所以这里我们需要new一个work on这个对象出来,
这个实力出来,
刚才我们不是已经写了work on这个实体类,
它的两个的一个构造方法,
一个是无参的构造方法,
另外一个就是有参的构造方法,
所以我们就采用这个work on实体类的有参的构造方法,
一个参数就是单词,
第二个参数就是每个单词它的数量,
这里每个单词它的数量,
我们都把它设定为1,这样子。
接下来上节课我们已经说了,
flink如果使用lambda的表达是如果采用了招瓦里面的犯行的话,
那么在反馈的时候必须要指定这个犯行它的类型,
不然的话flink是无法正确推断出这个犯行的类型的,
这里connect这个对象它的犯行是work on这个实体类,
所以我们在反馈的时候一定要指定这个犯行,
它是work on这个实体类,work on that class,这是第一步,
这里的第一步它不只是对数据进行切割,
还包括了对切割户的数据进行标记,
接下来就是第二步的分组,
这里的分组我们是通过key by这个算子,
那么扩耗里面的参数很明显的要输入分组的气质,
那么我们通过这样子的一种形式,work on这个实体类,
然后双帽号通过它的get world这个方法,
把每个单子把它取出来,
然后作为参数传进key by这个算子里面,
这里有一个知识点,就是这个双帽号,
双帽号它是一种lambar的语法,
也是一种lambar的语法,它是指什么意思呢?
它是指一个方法引用,引用,
那么这里的方法引用它的方式有很多种,
我们这里采用的是叫做静态方式的方法引用,
方法形式的方法引用,
这是方法引用的其中一种调用形式,
还有其他很多种调用形式,
那么我们这里就不详细的说它,
同学们只需要知道这个双帽号它就是一种lambar的语法,
下面就正式的进入到我们这节课的重点,
key by这个算子它会将datastream的数据类型转换为kisschimp的数据类型,
kisschimp这个数据类型它是一个特殊的datastream的数据类型,
在前几个课我们已经看过kisschimp这个原码了,
它是继承于datastream的数据类型,
然后在上一节课我们已经说过,
fring它的状态分为两个种类,
一个是叫做kiss state,
第二个是叫做operate state,
kiss state它是只能够应用于kisschimp这种数据类型,
所以状态计算它的逻辑只能够在key by这个算子之后,
就是kiss state这种类型的状态计算它只能够应用在key by这个算子之后,
重要的事情说三遍,
所以顺便说一下我们这节课所谓的状态计算的状态,
它的类型是kiss state的类型,
下面就正式的开始fring它的状态计算的具体逻辑,
我们通过fragMap这个算子来实现状态计算的具体逻辑,
前面我们已经说过了fragMap这个算子它的参数是一个fragMap方式的对象,
我们建立一个类,这个类是存放具体的状态计算的业务逻辑的,
然后这个类它是继承whichfragMap方式这个对象,
whichfragMap方式这个对象它是一个抽象类,
它是实现了fragMap方式这个接口,
所以我们新建的这个类也是实现了fragMap方式的接口,
所以我们这个新建的类是可以作为参数传入到fragMap这个算子。
总结一下,我们在进行状态计算的时候,
这里调用的fragMap这个算子里面,
它里面的参数本应该是要传入一个fragMap方式这个对象,
但是这里我们是new刚才我们建的这个类,
把它作为参数传进去。
那么为什么new这个类可以作为参数传到fragMap这个算子里面吗?
不是应该传入一个fragMap方式的对象吗?
因为这个类它继承了whichfragMap方式这个对象,
而whichfragMap方式这个对象,
它是实现了fragMap方式这个接口,
所以这个类是可以作为参数传到fragMap这个算子里面。
那么接下来我们的状态计算主要就是在这个类进行。
